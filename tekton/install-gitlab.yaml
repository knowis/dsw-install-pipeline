apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: install-gitlab
spec:
  params:
    - name: default-step-image
      type: string
      description: Image to use to execute step
    - name: install-namespace
      type: string
      description: "Namespace to install into"
    - name: operator-name
      type: string
      description: "Name of the GitLab operator"
      default: gitlab-operator-kubernetes
    - name: cluster-app-url
      type: string
      description: The cluster host needed to construct routes/ingresses in the form of apps.yourcloster.tld
    - name: gitlab-helm-chart-version
      type: string
      description: "Version of the helm chart that the operator should install. Needs to be compatible with the operator version."
      default: 9.8.2
    - name: keycloak-dsw-realm-name
      type: string
      description: "Name of realm in keycloak to be used for authenticating to DSW"
      default: "dsw"
    - name: keycloak-credentials-secret
      type: string
      description: "Name of the secret holding the admin credentials for keycloak"
      default: "keycloak-credentials"
    - name: keycloak-url
      type: string
      description: "Url of keycloak admin host (without protocol)"
  results:
    - name: release-status
      description: "The status of the Helm release"
  steps:
    - name: create-postgres-secrets
      image: image-registry.openshift-image-registry.svc:5000/techzone-test/dsw-tekton-base:0.0.2
      script: |
        #!/usr/bin/bash
        set -e

        echo "Starting generation of keycloak postgres secrets"

        # Create secret 'keycloak-postgres-postgres-credentials' if it doesn't exist yet
        if [ -z "$(oc get secret keycloak-postgres-postgres-credentials --ignore-not-found)" ]; then
          echo "Creating secret 'keycloak-postgres-postgres-credentials'"
          postgres_password=$(tr -dc 'A-Za-z0-9!?%=+_&;%§#-' < /dev/random | head -c 15)
          oc create secret generic keycloak-postgres-postgres-credentials --from-literal=postgres-password="${postgres_password}"
        else
          echo "Secret 'keycloak-postgres-postgres-credentials' already exists. Skipping…"
        fi

        # Create secret 'keycloak-postgres-keycloak-user-credentials' if it doesn't exist yet
        if [ -z "$(oc get secret keycloak-postgres-keycloak-user-credentials --ignore-not-found)" ]; then
          echo "Creating secret 'keycloak-postgres-keycloak-user-credentials'"
          keycloak_user_password=$(tr -dc 'A-Za-z0-9!?%=+_&;%§#-' < /dev/random | head -c 15)
          oc create secret generic keycloak-postgres-keycloak-user-credentials --from-literal=username=keycloak --from-literal=database=keycloak --from-literal=password="${keycloak_user_password}"
        else
          echo "Secret 'keycloak-postgres-keycloak-user-credentials' already exists. Skipping…"
        fi
    - name: install-postgres
      image: image-registry.openshift-image-registry.svc:5000/techzone-test/dsw-tekton-base:0.0.2
      script: |
        #!/usr/bin/bash
        set -e

        echo "Starting Helm installation..."

        # Build helm install command
        HELM_CMD="helm install $(params.release-name) $(params.chart-name)"

        # Add version if specified
        if [ -n "$(params.chart-version)" ]; then
          HELM_CMD="$HELM_CMD --version $(params.chart-version)"
        fi

        # Add set values if specified
        if [ -n "$(params.set-values)" ]; then
          HELM_CMD="$HELM_CMD --set $(params.set-values)"
        fi

        # Execute helm install
        echo "Executing: $HELM_CMD"
        eval $HELM_CMD

        # Get release status
        helm status $(params.release-name) | tee $(results.release-status.path)

        echo "Helm installation completed successfully!"
      env:
        - name: HOME
          value: /tmp

    - name: install-gitlab-operator
      image: "$(params.default-step-image)"
      script: |
        #!/usr/bin/bash
        set -e

        OP_NAME=$(params.operator-name)
        NS_INST=$(params.install-namespace)

        echo "Beginning installation of GitLab via operator $OP_NAME in namespace $NS_INST"

        # get details of latest ClusterServiceVersion in default channel
        default_channel="$(oc get packagemanifests $OP_NAME -o jsonpath="{.status.defaultChannel}")"

        latest_csv="$(oc get packagemanifests $OP_NAME -o jsonpath="{.status.channels[?(@.name=='${default_channel}')].entries[0].name}")"

        catalog_source="$(oc get packagemanifests $OP_NAME -o jsonpath={.status.catalogSource})"

        catalog_source_namespace="$(oc get packagemanifests $OP_NAME -o jsonpath={.status.catalogSourceNamespace})"

        # Create an OperatorGroup

        oc create -f - << EOF
        apiVersion: operators.coreos.com/v1
        kind: OperatorGroup
        metadata:
          generateName: $NS_INST-
          annotations:
            olm.providedAPIs: GitLab.v1beta1.apps.gitlab.com
          namespace: $NS_INST
        spec:
          targetNamespaces:
            - $NS_INST
          upgradeStrategy: Default
        EOF

        # Create a subscription

        oc apply -f - << EOF
        apiVersion: operators.coreos.com/v1alpha1
        kind: Subscription
        metadata:
          labels:
            operators.coreos.com/$OP_NAME.$NS_INST: ''
          name: $OP_NAME
          namespace: $NS_INST
        spec:
          channel: $default_channel
          installPlanApproval: Manual
          name: $OP_NAME
          source: $catalog_source
          sourceNamespace: $catalog_source_namespace
          startingCSV: $latest_csv
        EOF

        # Approve Installplan

        installplan_name="$(oc get installplan -o jsonpath="{.items[?(@.spec.clusterServiceVersionNames[0]=="$latest_csv")].metadata.name}" -n $NS_INST)"
        oc patch installplan/$installplan_name --type merge --patch '{"spec":{"approved": true}}' -n $NS_INST
        #

        echo "Installation of GitLab operator done"
    - name: create-oauth-secret
      image: "$(params.default-step-image)"
      script: |
        #!/usr/bin/bash
        set -e

        NS_INST=$(params.install-namespace)

        echo "Creating secret keycloak-oauth2 to configure openid for GitLab"



    - name: create-gitlab-instance
      image: "$(params.default-step-image)"
      script: |
        #!/usr/bin/bash
        set -e

        NS_INST=$(params.install-namespace)
        APP_URL=$(params.cluster-app-url)

        oc create -f - << EOF
        apiVersion: apps.gitlab.com/v1beta1
        kind: GitLab
        metadata:
          name: gitlab
          namespace: $NS_INST
        spec:
          chart:
            values:
              certmanager:
                install: false
              gitlab:
                migrations:
                  enabled: true
                toolbox:
                  antiAffinityLabels:
                    matchLabels:
                      app: gitaly
                  replicas: 1
              global:
                appConfig:
                  omniauth:
                    enabled: true
                    autoLinkSamlUser: false
                    providers:
                      - key: provider
                        secret: keycloak-oauth2
                    syncProfileAttributes:
                      - email
                    autoSignInWithProvider: null
                    syncProfileFromProvider:
                      - openid_connect
                    allowBypassTwoFactor: []
                    allowSingleSignOn:
                      - openid_connect
                    autoLinkUser: []
                    externalProviders: []
                    autoLinkLdapUser: false
                    blockAutoCreatedUsers: true
                gitaly:
                  authToken: {}
                  enabled: true
                  external: []
                  internal:
                    names:
                      - default
                  service:
                    externalPort: 8075
                    internalPort: 8075
                    name: gitaly
                    type: ClusterIP
                hosts:
                  domain: $APP_URL
                  https: true
                  minio:
                    name: minio-csw-gitlab.$APP_URL
                  smartcard: {}
                  hostSuffix: null
                  gitlab:
                    name: csw-gitlab.$APP_URL
                  tls: {}
                  registry:
                    name: csw-registry.$APP_URL
                  kas:
                    name: csw-kas.$APP_URL
                ingress:
                  annotations:
                    route.openshift.io/termination: edge
                  class: openshift-default
                  configureCertmanager: false
                  tls:
                    enabled: false
                    secretName: gitlab-secrets
                redis:
                  auth:
                    enabled: true
              postgresql:
                primary:
                  extendedConfiguration: max_connections = 200
              tls:
                application:
                  allowClusterRoles: true
                  create: false
                  links: []
                externalPort: 8076
                internalPort: 8076
            version: $(params.gitlab-helm-chart-version)
        EOF
